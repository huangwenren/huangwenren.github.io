<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wenren&#39;s World</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huangwenren.github.io/"/>
  <updated>2018-10-05T07:01:25.824Z</updated>
  <id>https://huangwenren.github.io/</id>
  
  <author>
    <name>huangwenren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>待整理</title>
    <link href="https://huangwenren.github.io/2018/09/09/%E5%BE%85%E6%95%B4%E7%90%86/"/>
    <id>https://huangwenren.github.io/2018/09/09/待整理/</id>
    <published>2018-09-09T11:20:51.000Z</published>
    <updated>2018-10-05T07:01:25.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>二叉树蛇形遍历 <a href="https://blog.csdn.net/qq_29996285/article/details/80428988" target="_blank" rel="noopener">二叉树的蛇形遍历 leetcode 103</a></li></ul><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul><li><a href="https://es.xiaoleilu.com/010_Intro/00_README.html" target="_blank" rel="noopener">Elasticsearch 权威指南</a></li></ul><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>-<a href="https://www.jiqizhixin.com/articles/2018-03-31?from=synced&amp;keyword=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6" target="_blank" rel="noopener">这是一份文科生都能看懂的线性代数简介</a></p><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>-<a href="https://start.spring.io/" target="_blank" rel="noopener">快速生成 Spring 模板</a></p><h2 id="DeepLearning4j"><a href="#DeepLearning4j" class="headerlink" title="DeepLearning4j"></a>DeepLearning4j</h2><p>-<a href="https://deeplearning4j.org/cn/quickstart" target="_blank" rel="noopener">DeepLearning4j中文文档</a></p><h1 id="标准ASCII字符一共多少个？"><a href="#标准ASCII字符一共多少个？" class="headerlink" title="标准ASCII字符一共多少个？"></a>标准ASCII字符一共多少个？</h1><p>基本 ASCII 是 128 个，扩展 ASCII 是 256 个</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><a href="https://blog.csdn.net/anxpp/article/details/51224293" target="_blank" rel="noopener">java 设计模式</a></p><h2 id="后端面试"><a href="#后端面试" class="headerlink" title="后端面试"></a>后端面试</h2><p><a href="https://juejin.im/entry/5af2557c6fb9a07aa83eb59c" target="_blank" rel="noopener">https://juejin.im/entry/5af2557c6fb9a07aa83eb59c</a></p><h1 id="java-nio-实例"><a href="#java-nio-实例" class="headerlink" title="java nio 实例"></a>java nio 实例</h1><p><a href="https://www.jianshu.com/p/a9d030fec081" target="_blank" rel="noopener">java nio 实例</a></p><h2 id="创建知乎-live"><a href="#创建知乎-live" class="headerlink" title="创建知乎 live"></a>创建知乎 live</h2><p><a href="https://www.zhihu.com/question/49007863" target="_blank" rel="noopener">创建知乎 live</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;二叉树蛇形遍历 &lt;a href=&quot;https://blog.csdn.net/qq_29996285/article/detai
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数字签名</title>
    <link href="https://huangwenren.github.io/2018/09/09/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    <id>https://huangwenren.github.io/2018/09/09/数字签名/</id>
    <published>2018-09-09T11:07:00.000Z</published>
    <updated>2018-09-09T11:11:19.555Z</updated>
    
    <content type="html"><![CDATA[<p>## </p><ol><li>对内容进行 hash 计算，然后得到摘要 digest </li><li>用私钥对摘要进行加密从而得到签名</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">数字签名是什么？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;## &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对内容进行 hash 计算，然后得到摘要 digest &lt;/li&gt;
&lt;li&gt;用私钥对摘要进行加密从而得到签名&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;&lt;a href=&quot;#参考文档&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="security" scheme="https://huangwenren.github.io/categories/security/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL基础知识</title>
    <link href="https://huangwenren.github.io/2018/09/09/MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://huangwenren.github.io/2018/09/09/MySQL基础知识/</id>
    <published>2018-09-09T10:52:24.000Z</published>
    <updated>2018-10-02T11:18:52.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。<br>一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。<br>因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。<br>同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，<strong>前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表</strong>。</p><h2 id="TRUNCATE-与-DELETE-的区别"><a href="#TRUNCATE-与-DELETE-的区别" class="headerlink" title="TRUNCATE 与 DELETE 的区别"></a>TRUNCATE 与 DELETE 的区别</h2><p>TRUNCATE 只能用来清除整个表的数据，而 DELETE 可以根据条件删除某些记录。此外，TRUNCATE 删除是不可恢复的！！！</p><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。&lt;br&gt;一般情况下，MySQL 数据库是选择的第一方案，基本上有 80%
      
    
    </summary>
    
      <category term="MySQL" scheme="https://huangwenren.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Shell编程</title>
    <link href="https://huangwenren.github.io/2018/09/06/Shell%E7%BC%96%E7%A8%8B/"/>
    <id>https://huangwenren.github.io/2018/09/06/Shell编程/</id>
    <published>2018-09-06T13:07:31.000Z</published>
    <updated>2018-10-05T07:31:18.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h2><ul><li>变量为 null 时，则 var=b</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line">var=<span class="variable">$&#123;a-b&#125;</span></span><br></pre></td></tr></table></figure><ul><li>变量为 null 且为空字符串，则 var=b</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line">var=<span class="variable">$&#123;a:-b&#125;</span></span><br></pre></td></tr></table></figure><ul><li>附：简单但不优雅的实现方式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="variable">$1</span> ]; <span class="keyword">then</span>  </span><br><span class="line">       <span class="variable">$1</span>=<span class="string">'default'</span>  </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>参考： <a href="http://www.mojidong.com/linux/2012/09/08/shell-set-default-value/" target="_blank" rel="noopener">shell中给变量设置默认值</a></p><h2 id="Shell-中调用其它-Shell"><a href="#Shell-中调用其它-Shell" class="headerlink" title="Shell 中调用其它 Shell"></a>Shell 中调用其它 Shell</h2><ul><li>fork</li></ul><p>terminal 会新开一个子 Shell 执行脚本，子 Shell 可以从父 Shell 继承环境变量，但是子 Shell 中的环境变量不会带回给父 Shell。</p><ul><li>source</li></ul><p><code>source</code> 与 <code>fork</code> 的区别是不新开一个子 Shell 来执行被调用的脚本，而是在同一个 Shell 中执行。所以被调用的脚本中声明的变量和环境变量, 都可以在主脚本中进行获取和使用。</p><ul><li>exec</li></ul><p><code>exec</code> 与 <code>fork</code> 不同，不需要新开一个子 Shell 来执行被调用的脚本. 被调用的脚本与父脚本在同一个 Shell 内执行。<strong>但是使用 <code>exec</code> 调用一个新脚本以后, 父脚本中 <code>exec</code> 行之后的内容就不会再执行了。这是 exec 和 source 的区别。</strong></p><p>参考： <a href="https://blog.csdn.net/simple_the_best/article/details/76285429" target="_blank" rel="noopener">在 Shell 脚本中调用另一个 Shell 脚本的三种方式</a></p><h2 id="处理命令行参数"><a href="#处理命令行参数" class="headerlink" title="处理命令行参数"></a>处理命令行参数</h2><ul><li>手工处理方式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>因为手工处理高度依赖于命令行上所传参数的位置，所以一般都只用来处理较简单的参数。</p><ul><li>getopts</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">"a:bc"</span> arg <span class="comment"># 选项后面的冒号表示该选项需要参数</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$arg</span> <span class="keyword">in</span></span><br><span class="line">        h | ? )</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"help"</span></span><br><span class="line">            <span class="built_in">exit</span> 0</span><br><span class="line">            ;;</span><br><span class="line">        a)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"a's arg: <span class="variable">$OPTARG</span>"</span> <span class="comment"># 参数存在$OPTARG中</span></span><br><span class="line">            ;;</span><br><span class="line">        b)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"b"</span></span><br><span class="line">            ;;</span><br><span class="line">        c)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"c"</span></span><br><span class="line">            ;;</span><br><span class="line">         ?)  <span class="comment"># 当有不认识的选项的时候arg为?</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"unkonw argument"</span></span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><code>getopts</code> 是由bash内置的，<strong>它不支持长选项</strong>。</p><ul><li>getopt</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo $@</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-o或--options选项后面接可接受的短选项，如ab:c::，表示可接受的短选项为-a -b -c，其中-a选项不接参数，-b选项后必须接参数，-c选项的参数为可选的</span></span><br><span class="line"><span class="comment">#-l或--long选项后面接可接受的长选项，用逗号分开，冒号的意义同短选项。</span></span><br><span class="line"><span class="comment">#-n选项后接选项解析错误时提示的脚本名字</span></span><br><span class="line">ARGS=`getopt -o ab:c:: --long along,blong:,clong:: -n <span class="string">'example.sh'</span> -- <span class="string">"<span class="variable">$@</span>"</span>`</span><br><span class="line"><span class="keyword">if</span> [ $? != 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Terminating..."</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo $ARGS</span></span><br><span class="line"><span class="comment">#将规范化后的命令行参数分配至位置参数（$1,$2,...)</span></span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">set</span> -- <span class="string">"<span class="variable">$&#123;ARGS&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">        -a|--along) </span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"Option a"</span>;</span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        -b|--blong)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"Option b, argument <span class="variable">$2</span>"</span>;</span><br><span class="line">            <span class="built_in">shift</span> 2</span><br><span class="line">            ;;</span><br><span class="line">        -c|--clong)</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"<span class="variable">$2</span>"</span> <span class="keyword">in</span></span><br><span class="line">                <span class="string">""</span>)</span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">"Option c, no argument"</span>;</span><br><span class="line">                    <span class="built_in">shift</span> 2  </span><br><span class="line">                    ;;</span><br><span class="line">                *)</span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">"Option c, argument <span class="variable">$2</span>"</span>;</span><br><span class="line">                    <span class="built_in">shift</span> 2;</span><br><span class="line">                    ;;</span><br><span class="line">            <span class="keyword">esac</span></span><br><span class="line">            ;;</span><br><span class="line">        --)</span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"Internal error!"</span></span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#处理剩余的参数</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"processing <span class="variable">$arg</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><code>getopt</code> 和 <code>getopts</code> 功能相似但又不完全相同，<code>getopt</code> 是独立的可执行文件</p><p>参考：</p><ul><li><a href="https://blog.linuxeye.cn/389.html" target="_blank" rel="noopener">getopt：命令行选项、参数处理</a></li><li><a href="http://www.cnblogs.com/FrankTan/archive/2010/03/01/1634516.html" target="_blank" rel="noopener">Shell 中命令行选项/参数处理</a></li><li><a href="http://yejinxin.github.io/parse-shell-options-with-getopt-command" target="_blank" rel="noopener">使用 getopt 命令解析 shell 脚本的命令行选项</a></li><li><p><a href="https://www.cnblogs.com/yxzfscg/p/5338775.html" target="_blank" rel="noopener">解析命令行参数工具：getopts/getopt</a> </p><h2 id="if-语句的一些特殊判断"><a href="#if-语句的一些特殊判断" class="headerlink" title="if 语句的一些特殊判断"></a>if 语句的一些特殊判断</h2></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p> Shell 字符串以 <code>&#39; &#39;</code> 或者 <code>&quot; &quot;</code> 进行包围。如果是以 <code>&#39; &#39;&#39;</code> 进行包围的话，则会对单引号里面的内容进行原封不动的输出，如果是以 <code>&quot; &quot;&quot;</code> 进行包围的话，输出时会先解析里面的变量和命令。</p><h2 id="将命令的结果赋值给变量"><a href="#将命令的结果赋值给变量" class="headerlink" title="将命令的结果赋值给变量"></a>将命令的结果赋值给变量</h2><p>有两种方式：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var=`<span class="built_in">command</span>`</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">var=$(<span class="built_in">command</span>)</span><br></pre></td></tr></table></figure></p><p>由于第一种方式和定义字符串的方式有点像，容易造成混淆。因此，通常建议使用 <code>$(command)</code> 的方式将命令的结果赋值给变量。</p><h2 id="利用-expr-进行数学运算"><a href="#利用-expr-进行数学运算" class="headerlink" title="利用 expr 进行数学运算"></a>利用 expr 进行数学运算</h2><p>eg:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val=`expr 1 + 1`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$val</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设置默认值&quot;&gt;&lt;a href=&quot;#设置默认值&quot; class=&quot;headerlink&quot; title=&quot;设置默认值&quot;&gt;&lt;/a&gt;设置默认值&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;变量为 null 时，则 var=b&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="Shell" scheme="https://huangwenren.github.io/categories/Shell/"/>
    
    
  </entry>
  
  <entry>
    <title>学习资源</title>
    <link href="https://huangwenren.github.io/2018/09/06/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    <id>https://huangwenren.github.io/2018/09/06/学习资源/</id>
    <published>2018-09-06T13:00:22.000Z</published>
    <updated>2018-09-06T13:03:29.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔面试相关"><a href="#笔面试相关" class="headerlink" title="笔面试相关"></a>笔面试相关</h2><ul><li><a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/index.html" target="_blank" rel="noopener">《编程之法：面试和算法心得》</a></li></ul><p>-<a href=""></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;笔面试相关&quot;&gt;&lt;a href=&quot;#笔面试相关&quot; class=&quot;headerlink&quot; title=&quot;笔面试相关&quot;&gt;&lt;/a&gt;笔面试相关&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://wizardforcel.gitbooks.io/the-art-of
      
    
    </summary>
    
      <category term="资源" scheme="https://huangwenren.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Dockerfile入门</title>
    <link href="https://huangwenren.github.io/2018/09/06/Dockerfile%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/09/06/Dockerfile入门/</id>
    <published>2018-09-06T12:38:23.000Z</published>
    <updated>2018-09-06T12:56:50.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前台运行"><a href="#前台运行" class="headerlink" title="前台运行"></a>前台运行</h2><ol><li>方法一：通过循环实现</li></ol><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM $&#123;BASE_IMAGE&#125;</span><br><span class="line"></span><br><span class="line">MAINTAINER huangwenren &lt;huangwenren1994@foxmail.com&gt;</span><br><span class="line"></span><br><span class="line">COPY ./bin/configtxgen /usr/local/bin/</span><br><span class="line"></span><br><span class="line">RUN chmod +x /usr/local/bin/configtxgen</span><br><span class="line"></span><br><span class="line">COPY ./configtx.yaml /etc/hyperledger/</span><br><span class="line"></span><br><span class="line">RUN apt-get install -y apg</span><br><span class="line"></span><br><span class="line">EXPOSE 7054</span><br><span class="line"></span><br><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;while true; do echo &apos;fabric-ca-client is running&apos;; sleep 10; done&quot; ]</span><br></pre></td></tr></table></figure><ol start="2"><li>方法二： 通过 supervisor 管理</li></ol><p>eg:</p><ol start="3"><li>方法三： 如果该程序支持前台运行，则可直接要求程序以前台形式运行</li></ol><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-拷贝保存子目录结构"><a href="#Dockerfile-拷贝保存子目录结构" class="headerlink" title="Dockerfile 拷贝保存子目录结构"></a>Dockerfile 拷贝保存子目录结构</h2><p>错误方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY files/* /files/</span><br></pre></td></tr></table></figure><p>正确方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY files/ /files/</span><br></pre></td></tr></table></figure><p>两者区别在于有无 * 标</p><p>参考： <a href="https://codeday.me/bug/20170910/68286.html" target="_blank" rel="noopener">Dockerfile 拷贝保存子目录结构</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">Docker —— 从入门到实践</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前台运行&quot;&gt;&lt;a href=&quot;#前台运行&quot; class=&quot;headerlink&quot; title=&quot;前台运行&quot;&gt;&lt;/a&gt;前台运行&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;方法一：通过循环实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="Docker" scheme="https://huangwenren.github.io/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>balance-transfer 测试</title>
    <link href="https://huangwenren.github.io/2018/09/02/balance-transfer%E6%B5%8B%E8%AF%95/"/>
    <id>https://huangwenren.github.io/2018/09/02/balance-transfer测试/</id>
    <published>2018-09-02T09:41:45.424Z</published>
    <updated>2018-09-09T12:21:13.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载-fabric-sample-代码"><a href="#下载-fabric-sample-代码" class="headerlink" title="下载 fabric-sample 代码"></a>下载 fabric-sample 代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hyperledger/fabric-samples.git</span><br></pre></td></tr></table></figure><h2 id="进入-fabric-sample-目录"><a href="#进入-fabric-sample-目录" class="headerlink" title="进入 fabric-sample 目录"></a>进入 fabric-sample 目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fabric-samples</span><br></pre></td></tr></table></figure><h2 id="下载二进制文件，需指定当前-fabric-sample-的版本"><a href="#下载二进制文件，需指定当前-fabric-sample-的版本" class="headerlink" title="下载二进制文件，需指定当前 fabric-sample 的版本"></a>下载二进制文件，需指定当前 fabric-sample 的版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://goo.gl/6wtTN5 | bash -s <span class="variable">$&#123;VERSION&#125;</span></span><br></pre></td></tr></table></figure><p>最近发现了一个<strong>速度更快的方法</strong>。<br>这个脚本文件其实在 fabric 中就已经存在了，直接利用 fabric 中的脚本也可以得到与上面命令一样的效果，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric/scripts/bootstrap.sh ./</span><br><span class="line"></span><br><span class="line">chmod +x bootstrap.sh</span><br><span class="line"></span><br><span class="line">./bootstrap.sh</span><br></pre></td></tr></table></figure><h2 id="进入-balance-transfer-目录"><a href="#进入-balance-transfer-目录" class="headerlink" title="进入 balance-transfer 目录"></a>进入 balance-transfer 目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> balance-transfer</span><br></pre></td></tr></table></figure><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h2><p>1.终端 1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./runApp.sh</span><br></pre></td></tr></table></figure><p>2.终端 2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y jq</span><br><span class="line"></span><br><span class="line">./testApp.sh</span><br></pre></td></tr></table></figure><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h2><ol><li>终端 1</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f artifacts/docker-compose.yaml up</span><br></pre></td></tr></table></figure><ol start="2"><li>终端 2</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 node app，监听4000端口：</span></span><br><span class="line">PORT=4000 node app</span><br></pre></td></tr></table></figure><ol start="3"><li>在终端 3 通过 <code>curl</code> 命令进行测试</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/zhayujie5200/article/details/79684032" target="_blank" rel="noopener">balance transfer（一）启动示例</a></li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li>balance-transfer 运行 testAPIs.sh 遇到：Hyperledger fabric :Failed to join all peers to channel. cause:TypeError: client.getEventHubsForOrg is not a function</li></ol><p>参考<a href="https://stackoverflow.com/questions/51476679/hyperledger-fabric-failed-to-join-all-peers-to-channel-causetypeerror-client" target="_blank" rel="noopener">Stack Overflow</a></p><p>解决方法：</p><p>将 app/joinChannel.js 中的 <code>let event_hubs = client.getEventHubsForOrg(org_name);</code> 替换为 <code>let event_hubs = channel.getChannelEventHubsForOrg(org_name);</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;下载-fabric-sample-代码&quot;&gt;&lt;a href=&quot;#下载-fabric-sample-代码&quot; class=&quot;headerlink&quot; title=&quot;下载 fabric-sample 代码&quot;&gt;&lt;/a&gt;下载 fabric-sample 代码&lt;/h2&gt;&lt;figu
      
    
    </summary>
    
      <category term="Fabric" scheme="https://huangwenren.github.io/categories/Fabric/"/>
    
    
  </entry>
  
  <entry>
    <title>CouchDB入门</title>
    <link href="https://huangwenren.github.io/2018/08/29/CouchDB%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/08/29/CouchDB入门/</id>
    <published>2018-08-29T14:29:10.000Z</published>
    <updated>2018-08-29T14:35:40.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CouchDB是一个开源的面向文档的数据库管理系统。</p><h2 id="CouchDB-与-MongoDB-对比"><a href="#CouchDB-与-MongoDB-对比" class="headerlink" title="CouchDB 与 MongoDB 对比"></a>CouchDB 与 MongoDB 对比</h2><p>满足海量存储需求和访问的面向文档的数据库：MongoDB，CouchDB</p><p>面向文档的非关系数据库主要解决的问题不是高性能的并发读写，而是保证海量数据存储的同时，具有良好的查询性能。MongoDB是用C++开发的，而 CouchDB则是Erlang开发的：</p><ol><li>MongoDB</li></ol><p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似 json 的 bjson 格式，因此可以存储比较复杂的数据类型。Mongo 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><p>Mongo 主要解决的是海量数据的访问效率问题，根据官方的文档，当数据量达到50GB以上的时候，Mong o的数据库访问速度是 MySQL 的 10 倍以 上。Mongo 的并发读写效率不是特别出色，根据官方提供的性能测试表明，大约每秒可以处理 0.5 万－1.5 万次读写请求。</p><p>因为 Mongo 主要是支持海量数据存储的，所以 Mongo 还自带了一个出色的分布式文件系统 GridFS，可以支持海量的数据存储，但我也看到有些评论认为 GridFS 性能不佳，这一点还是有待亲自做点测试来验证了。</p><p>最后由于 Mongo 可以支持复杂的数据结构，而且带有强大的数据查询功能，因此非常受到欢迎，很多项目都考虑用 MongoDB 来替代 MySQL 来实现不是 特别复杂的 Web 应用，比方说 why we migrated from MySQL to MongoDB 就是一个真实的从MySQL迁移到 MongoDB 的案例，由于数据量实在太大，所以迁移到了 Mongo 上面，数据查询的速度得到了非常显著的提升。</p><p>MongoD B也有一个 ruby 的项目 MongoMapper，是模仿 Merb 的 DataMapper 编写的 MongoDB 的接口，使用起来非常简单，几乎和 DataMapper 一模一样，功能非常强大易用。</p><ol start="2"><li>CouchDB</li></ol><p>CouchDB现在是一个非常有名气的项目，似乎不用多介绍了。但是我却对 CouchDB 没有什么兴趣，主要是因为 CouchDB 仅仅提供了基于 HTTP REST 的接口，因此 CouchDB 单纯从并发读写性能来说，是非常糟糕的，这让我立刻抛弃了对 CouchDB 的兴趣。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;CouchDB是一个开源的面向文档的数据库管理系统。&lt;/p&gt;
&lt;h2 id=&quot;CouchDB-与-MongoDB-对比&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="CouchDB" scheme="https://huangwenren.github.io/categories/CouchDB/"/>
    
    
  </entry>
  
  <entry>
    <title>BitMap算法</title>
    <link href="https://huangwenren.github.io/2018/08/29/BitMap%E7%AE%97%E6%B3%95/"/>
    <id>https://huangwenren.github.io/2018/08/29/BitMap算法/</id>
    <published>2018-08-29T06:14:39.000Z</published>
    <updated>2018-09-09T11:02:43.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BitMap-Java-实现"><a href="#BitMap-Java-实现" class="headerlink" title="BitMap Java 实现"></a>BitMap Java 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitTest</span> </span>&#123;  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 1 3 6 10 100</span></span><br><span class="line">          BitSet bitSet = <span class="keyword">new</span> BitSet(<span class="number">100</span>);</span><br><span class="line">  </span><br><span class="line">          bitSet.set(<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">          bitSet.set(<span class="number">3</span>, <span class="keyword">true</span>);</span><br><span class="line">          bitSet.set(<span class="number">6</span>, <span class="keyword">true</span>);</span><br><span class="line">          bitSet.set(<span class="number">100</span>, <span class="keyword">true</span>);</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitSet.size(); i++) &#123;</span><br><span class="line">              <span class="keyword">boolean</span> b = bitSet.get(i);</span><br><span class="line">  </span><br><span class="line">              <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                  System.out.println(i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考 <a href="http://15838341661-139-com.iteye.com/blog/1564969" target="_blank" rel="noopener">JAVA海量数据处理之二（BitMap）</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BitMap-Java-实现&quot;&gt;&lt;a href=&quot;#BitMap-Java-实现&quot; class=&quot;headerlink&quot; title=&quot;BitMap Java 实现&quot;&gt;&lt;/a&gt;BitMap Java 实现&lt;/h2&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://huangwenren.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下密码生成软件APG</title>
    <link href="https://huangwenren.github.io/2018/08/29/Linux%E4%B8%8B%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E8%BD%AF%E4%BB%B6APG/"/>
    <id>https://huangwenren.github.io/2018/08/29/Linux下密码生成软件APG/</id>
    <published>2018-08-29T03:48:36.000Z</published>
    <updated>2018-08-29T03:59:14.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>APG是一款轻巧的密码生成软件，全称 Automated Password Generator（简称“APG”）。APG 在 Linux 使用，当然也有 Windows 版的，命令简单，可以批量生成，当需要若干随机密码时，可用该软件。</p><h2 id="APG-的使用"><a href="#APG-的使用" class="headerlink" title="APG 的使用"></a>APG 的使用</h2><p>直接输入 <code>apg</code> 默认生成 6 个随机密码</p><h2 id="APG-的可选参数"><a href="#APG-的可选参数" class="headerlink" title="APG 的可选参数"></a>APG 的可选参数</h2><p>m 指生成密码的位数，默认是8位</p><p>M mode  使用模式生成密码</p><p>-M mode S, s, N, n, C, c, L, l.</p><p>S  每个密码必须都有特殊字符</p><p>s  包含特殊字条但不一定每个都有</p><p>N  每个密码必需含有数字</p><p>n  包含数字</p><p>C  每个密码必需有大写字母</p><p>c  包含大写字母</p><p>L  每个密码必需有小写字母</p><p>l  包含有小写</p><h2 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h2><p>随机生成 7 个 16 位的包含大小写、特殊字符、数字的密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apg -M SNCL -m 16 -n 7</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/xhch2009/article/details/18222263" target="_blank" rel="noopener">Linux下密码生成软件APG</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;APG是一款轻巧的密码生成软件，全称 Automated Password Generator（简称“APG”）。APG 在 Linux 使
      
    
    </summary>
    
      <category term="Linux" scheme="https://huangwenren.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>利用Vagrant搭建Fabric开发环境</title>
    <link href="https://huangwenren.github.io/2018/08/28/%E5%88%A9%E7%94%A8Vagrant%E6%90%AD%E5%BB%BAFabric%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://huangwenren.github.io/2018/08/28/利用Vagrant搭建Fabric开发环境/</id>
    <published>2018-08-28T14:52:34.000Z</published>
    <updated>2018-08-28T14:52:59.747Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Fabric" scheme="https://huangwenren.github.io/categories/Fabric/"/>
    
    
  </entry>
  
  <entry>
    <title>ES入门</title>
    <link href="https://huangwenren.github.io/2018/08/28/ES%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/08/28/ES入门/</id>
    <published>2018-08-28T13:45:03.000Z</published>
    <updated>2018-10-02T11:16:35.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ElasticSearch-介绍"><a href="#ElasticSearch-介绍" class="headerlink" title="ElasticSearch 介绍"></a>ElasticSearch 介绍</h2><p>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。<br>其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。<br>ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。<br>此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。<br>因此，可以 <strong>使用 ElasticSearch 作为关系型数据库全文搜索的功能补充</strong>，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。</p><p>ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。著名的 ELK 日志处理方案，由 ElasticSearch、Logstash 和 Kibana 三个组件组成，包括了日志收集、聚合、多维度查询、可视化显示等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ElasticSearch-介绍&quot;&gt;&lt;a href=&quot;#ElasticSearch-介绍&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch 介绍&quot;&gt;&lt;/a&gt;ElasticSearch 介绍&lt;/h2&gt;&lt;p&gt;在一般情况下，关系型数据库的
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://huangwenren.github.io/categories/Elasticsearch/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx反向代理</title>
    <link href="https://huangwenren.github.io/2018/08/28/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://huangwenren.github.io/2018/08/28/Nginx反向代理/</id>
    <published>2018-08-28T13:37:29.000Z</published>
    <updated>2018-08-28T13:42:42.100Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map <span class="variable">$http_upgrade</span> <span class="variable">$connection_upgrade</span> &#123;</span><br><span class="line">    default upgrade;</span><br><span class="line">    <span class="string">''</span>  close;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改Nginx的配置文件（具体配置文件的路径，参照Nginx的安装路径。在10.19.49.64这台物理机上，nginx安装在/usr/local/nginx）</span></span><br><span class="line">vim /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在nginx.conf中添加如下内容：</span></span><br><span class="line"> </span><br><span class="line">        location /<span class="variable">$&#123;cluster&#125;</span>/<span class="variable">$&#123;keytab&#125;</span>/ &#123;</span><br><span class="line">            proxy_pass  http://<span class="variable">$&#123;ip&#125;</span>:<span class="variable">$&#123;port&#125;</span>/;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">            proxy_set_header Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Nginx" scheme="https://huangwenren.github.io/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux中增加swap空间</title>
    <link href="https://huangwenren.github.io/2018/08/28/Linux%E4%B8%AD%E5%A2%9E%E5%8A%A0swap%E7%A9%BA%E9%97%B4/"/>
    <id>https://huangwenren.github.io/2018/08/28/Linux中增加swap空间/</id>
    <published>2018-08-28T02:53:58.000Z</published>
    <updated>2018-08-28T14:07:04.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于 memory 没什么可说的就是机器的物理内存，读写速度低于 cpu 一个量级，但是高于磁盘不止一个量级。所以，程序和数据如果在内存的话，会有非常快的读写速度。但是，内存的造价是要高于磁盘的，虽然相对来说价格一直在降低。除此之外，内存的断电丢失数据也是一个原因说不能把所有数据和程序都保存在内存中。既然不能全部使用内存，那数据还有程序肯定不可能一直霸占在内存中。当内存没有可用的，就必须要把内存中不经常运行的程序给踢出去。但是踢到哪里去，这时候 swap 就出现了。swap 全称为 swap place，，即交换区，当内存不够的时候，被踢出的进程被暂时存储到交换区。当需要这条被踢出的进程的时候，就从交换区重新加载到内存，否则它不会主动交换到真是内存中。</p><p>在安装 Linux 的时候，不知道 swap 空间分配多少比较好，所以会随便分配一个。在真正使用的时候，比如安装 Oracle10g 会要求很大的 swap 空间，发现 swap 空间不够，那应该怎么增加 swap 空间大小呢。</p><h2 id="查看原-swap-分区大小"><a href="#查看原-swap-分区大小" class="headerlink" title="查看原 swap 分区大小"></a>查看原 swap 分区大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free m</span><br></pre></td></tr></table></figure><h2 id="建立一个分区"><a href="#建立一个分区" class="headerlink" title="建立一个分区"></a>建立一个分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/home/swap bs=1024 count=512000</span><br></pre></td></tr></table></figure><p>这样就会创建 /home/swap 这么一个分区文件。文件的大小是 512000 个 block，一般情况下 1 个 block 为 1K，所以这里空间是 512M。</p><h2 id="将分区变成-swap-分区"><a href="#将分区变成-swap-分区" class="headerlink" title="将分区变成 swap 分区"></a>将分区变成 swap 分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/mkswap /home/swap</span><br></pre></td></tr></table></figure><h2 id="使用这个-swap-分区-使其成为有效状态"><a href="#使用这个-swap-分区-使其成为有效状态" class="headerlink" title="使用这个 swap 分区,使其成为有效状态"></a>使用这个 swap 分区,使其成为有效状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/swapon /home/swap</span><br></pre></td></tr></table></figure><h2 id="查看当前内存和-swap-分区大小"><a href="#查看当前内存和-swap-分区大小" class="headerlink" title="查看当前内存和 swap 分区大小"></a>查看当前内存和 swap 分区大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free m</span><br></pre></td></tr></table></figure><p>可以发现增加了 512M 的空间了。不过当计算机重启了以后，发现 swap 还是原来那么大，新的 swap 没有自动启动，还要手动启动。那我们需要修改 /etc/fstab 文件，增加如下一行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/swap swap swap defaults 0 0</span><br></pre></td></tr></table></figure><p>这样一来，机器就算重新启动，swap 空间也会自动增大。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/zwan0518/article/details/12059213" target="_blank" rel="noopener">Linux中Swap与Memory内存简单介绍</a><br><a href="https://blog.csdn.net/zhang123456456/article/details/78055059" target="_blank" rel="noopener">Linux之增加swap空间</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;对于 memory 没什么可说的就是机器的物理内存，读写速度低于 cpu 一个量级，但是高于磁盘不止一个量级。所以，程序和数据如果在内存的话
      
    
    </summary>
    
      <category term="Linux" scheme="https://huangwenren.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Git入门</title>
    <link href="https://huangwenren.github.io/2018/08/27/Git%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/08/27/Git入门/</id>
    <published>2018-08-27T15:04:22.000Z</published>
    <updated>2018-08-27T15:04:37.987Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Git" scheme="https://huangwenren.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Top K问题</title>
    <link href="https://huangwenren.github.io/2018/08/27/TopK%E9%97%AE%E9%A2%98/"/>
    <id>https://huangwenren.github.io/2018/08/27/TopK问题/</id>
    <published>2018-08-27T03:44:40.549Z</published>
    <updated>2018-09-06T13:05:27.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><h3 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h3><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://songlee24.github.io/2015/03/21/hua-wei-OJ2051/" target="_blank" rel="noopener">华为OJ2051-最小的K个数（Top K问题）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解法&quot;&gt;&lt;a href=&quot;#解法&quot; class=&quot;headerlink&quot; title=&quot;解法&quot;&gt;&lt;/a&gt;解法&lt;/h2&gt;&lt;h3 id=&quot;解法一&quot;&gt;&lt;a href=&quot;#解法一&quot; class=&quot;headerlink&quot; title=&quot;解法一&quot;&gt;&lt;/a&gt;解法一&lt;/h3&gt;&lt;h
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://huangwenren.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo文章摘要</title>
    <link href="https://huangwenren.github.io/2018/08/26/Hexo%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81/"/>
    <id>https://huangwenren.github.io/2018/08/26/Hexo文章摘要/</id>
    <published>2018-08-26T08:28:54.357Z</published>
    <updated>2018-08-27T14:58:30.107Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><a id="more"></a><p>正文内容</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://huangwenren.github.io/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>first-network测试</title>
    <link href="https://huangwenren.github.io/2018/08/23/first-network%E6%B5%8B%E8%AF%95/"/>
    <id>https://huangwenren.github.io/2018/08/23/first-network测试/</id>
    <published>2018-08-23T09:34:02.052Z</published>
    <updated>2018-08-28T14:10:53.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载-fabric-sample-代码"><a href="#下载-fabric-sample-代码" class="headerlink" title="下载 fabric-sample 代码"></a>下载 fabric-sample 代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hyperledger/fabric-samples.git</span><br></pre></td></tr></table></figure><h2 id="进入-fabric-sample-目录"><a href="#进入-fabric-sample-目录" class="headerlink" title="进入 fabric-sample 目录"></a>进入 fabric-sample 目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fabric-samples</span><br></pre></td></tr></table></figure><h2 id="下载二进制文件，需指定当前-fabric-sample-的版本"><a href="#下载二进制文件，需指定当前-fabric-sample-的版本" class="headerlink" title="下载二进制文件，需指定当前 fabric-sample 的版本"></a>下载二进制文件，需指定当前 fabric-sample 的版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://goo.gl/6wtTN5 | bash -s <span class="variable">$&#123;VERSION&#125;</span></span><br></pre></td></tr></table></figure><p>最近发现了一个<strong>速度更快的方法</strong>。<br>这个脚本文件其实在 fabric 中就已经存在了，直接利用 fabric 中的脚本也可以得到与上面命令一样的效果，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric/scripts/bootstrap.sh ./</span><br><span class="line"></span><br><span class="line">chmod +x bootstrap.sh</span><br><span class="line"></span><br><span class="line">./bootstrap.sh</span><br></pre></td></tr></table></figure><h2 id="进入-first-network-目录"><a href="#进入-first-network-目录" class="headerlink" title="进入 first-network 目录"></a>进入 first-network 目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> first-network</span><br></pre></td></tr></table></figure><h2 id="生成网络构件"><a href="#生成网络构件" class="headerlink" title="生成网络构件"></a>生成网络构件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./byfn.sh generate</span><br></pre></td></tr></table></figure><h2 id="启动网络"><a href="#启动网络" class="headerlink" title="启动网络"></a>启动网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./byfn.sh up</span><br></pre></td></tr></table></figure><h2 id="关闭网络"><a href="#关闭网络" class="headerlink" title="关闭网络"></a>关闭网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./byfn.sh down</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://hyperledger-fabric.readthedocs.io/en/latest/build_network.html" target="_blank" rel="noopener">官方文档</a><br><a href="https://hyperledger-fabric.readthedocs.io/en/latest/install.html" target="_blank" rel="noopener">安装二进制文件</a><br><a href="https://blog.csdn.net/mellymengyan/article/details/77671185" target="_blank" rel="noopener">cryptogen tool not found. exiting错误解决办法</a></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li>没有 down 网络，导致 up 网络失败。解决方法：先 down 网络，然后再 up <a href="https://stackoverflow.com/questions/48151804/error-got-unexpected-status-forbidden-failed-to-reach-implicit-threshold-of?rq=1" target="_blank" rel="noopener">详情可参照这个 stack overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;下载-fabric-sample-代码&quot;&gt;&lt;a href=&quot;#下载-fabric-sample-代码&quot; class=&quot;headerlink&quot; title=&quot;下载 fabric-sample 代码&quot;&gt;&lt;/a&gt;下载 fabric-sample 代码&lt;/h2&gt;&lt;figu
      
    
    </summary>
    
      <category term="Fabric" scheme="https://huangwenren.github.io/categories/Fabric/"/>
    
    
  </entry>
  
  <entry>
    <title>Vagrant 入门</title>
    <link href="https://huangwenren.github.io/2018/08/22/vagrant%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/08/22/vagrant入门/</id>
    <published>2018-08-22T09:05:40.000Z</published>
    <updated>2018-08-27T14:57:10.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p><strong>Vagrant 和 VirtualBox 的版本需要对应好，否则 Vagrant 可能会无法操作VirtualBox</strong></p><p>目前在以下版本测试成功（<a href="https://www.vagrantup.com/docs/virtualbox/" target="_blank" rel="noopener">查看 Vagrant 支持的 VirtualBox 版本</a>）：</p><ul><li>Vagrant 1.9.3</li><li>VirtualBox 4.3.40</li></ul><h2 id="Vagrant-Box-下载"><a href="#Vagrant-Box-下载" class="headerlink" title="Vagrant Box 下载"></a>Vagrant Box 下载</h2><p><a href="http://www.vagrantbox.es/" target="_blank" rel="noopener">Vagrant Box 下载地址</a></p><h2 id="Vagrant-常用命令"><a href="#Vagrant-常用命令" class="headerlink" title="Vagrant 常用命令"></a>Vagrant 常用命令</h2><ul><li>vagrant box add    添加box的操作</li><li>vagrant init    初始化box的操作，会生成 vagrant 的配置文件 Vagrantfile</li><li>vagrant up    启动本地环境</li><li>vagrant ssh    通过 ssh 登录本地环境所在虚拟机</li><li>vagrant halt    关闭本地环境</li><li>vagrant suspend    暂停本地环境</li><li>vagrant resume    恢复本地环境</li><li>vagrant reload    修改了 Vagrantfile 后，使之生效（相当于先 halt，再 up）</li><li>vagrant destroy    彻底移除本地环境</li><li>vagrant box list    显示当前已经添加的box列表</li><li>vagrant box remove    删除相应的box</li><li>vagrant package    打包命令，可以把当前的运行的虚拟机环境进行打包</li><li>vagrant plugin    用于安装卸载插件</li><li>vagrant status    获取当前虚拟机的状态</li><li>vagrant global-status    显示当前用户 vagrant 的所有环境状态</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.imooc.com/search/?words=vagrant" target="_blank" rel="noopener">慕课网教学视频</a></li><li><a href="https://github.com/apanly/mooc/tree/master/vagrant" target="_blank" rel="noopener">慕课网教学视频对应 GitHub</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;版本选择&quot;&gt;&lt;a href=&quot;#版本选择&quot; class=&quot;headerlink&quot; title=&quot;版本选择&quot;&gt;&lt;/a&gt;版本选择&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Vagrant 和 VirtualBox 的版本需要对应好，否则 Vagrant 可能会无法操作Virtua
      
    
    </summary>
    
      <category term="Vagrant" scheme="https://huangwenren.github.io/categories/Vagrant/"/>
    
    
  </entry>
  
  <entry>
    <title>docker入门</title>
    <link href="https://huangwenren.github.io/2018/08/22/docker%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/08/22/docker入门/</id>
    <published>2018-08-22T08:54:03.000Z</published>
    <updated>2018-09-09T11:05:34.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#确保 yum 包更新到最新</span></span><br><span class="line">sudo yum update</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行 Docker 安装脚本,执行这个脚本会添加 docker.repo 源并安装 Docker。</span></span><br><span class="line">curl -fsSL https://get.docker.com/ | sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动 Docker 进程</span></span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证 docker 是否安装成功并在容器中执行一个测试的镜像</span></span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a>删除所有容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure><h2 id="删除所有镜像"><a href="#删除所有镜像" class="headerlink" title="删除所有镜像"></a>删除所有镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $(docker images -aq)</span><br></pre></td></tr></table></figure><h2 id="容器中查看-Linux-版本"><a href="#容器中查看-Linux-版本" class="headerlink" title="容器中查看 Linux 版本"></a>容器中查看 Linux 版本</h2><p>正确的姿势：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure></p><p>错误的姿势：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version </span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">uname -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上诉两个方法查到的是宿主机的系统</span></span><br></pre></td></tr></table></figure></p><h2 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h2><p><a href="http://note.qidong.name/2017/06/26/docker-clean/" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-Docker&quot;&gt;&lt;a href=&quot;#安装-Docker&quot; class=&quot;headerlink&quot; title=&quot;安装 Docker&quot;&gt;&lt;/a&gt;安装 Docker&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="Docker" scheme="https://huangwenren.github.io/categories/Docker/"/>
    
    
  </entry>
  
</feed>
