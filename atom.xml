<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wenren&#39;s World</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huangwenren.github.io/"/>
  <updated>2018-09-06T14:42:47.014Z</updated>
  <id>https://huangwenren.github.io/</id>
  
  <author>
    <name>huangwenren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shell编程</title>
    <link href="https://huangwenren.github.io/2018/09/06/Shell%E7%BC%96%E7%A8%8B/"/>
    <id>https://huangwenren.github.io/2018/09/06/Shell编程/</id>
    <published>2018-09-06T13:07:31.000Z</published>
    <updated>2018-09-06T14:42:47.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h2><ul><li>变量为 null 时，则 var=b</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line">var=<span class="variable">$&#123;a-b&#125;</span></span><br></pre></td></tr></table></figure><ul><li>变量为 null 且为空字符串，则 var=b</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line">var=<span class="variable">$&#123;a:-b&#125;</span></span><br></pre></td></tr></table></figure><ul><li>附：简单但不优雅的实现方式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="variable">$1</span> ]; <span class="keyword">then</span>  </span><br><span class="line">       <span class="variable">$1</span>=<span class="string">'default'</span>  </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>参考： <a href="http://www.mojidong.com/linux/2012/09/08/shell-set-default-value/" target="_blank" rel="noopener">shell中给变量设置默认值</a></p><h2 id="Shell-中调用其它-Shell"><a href="#Shell-中调用其它-Shell" class="headerlink" title="Shell 中调用其它 Shell"></a>Shell 中调用其它 Shell</h2><ul><li>fork</li></ul><p>terminal 会新开一个子 Shell 执行脚本，子 Shell 可以从父 Shell 继承环境变量，但是子 Shell 中的环境变量不会带回给父 Shell。</p><ul><li>source</li></ul><p><code>source</code> 与 <code>fork</code> 的区别是不新开一个子 Shell 来执行被调用的脚本，而是在同一个 Shell 中执行。所以被调用的脚本中声明的变量和环境变量, 都可以在主脚本中进行获取和使用。</p><ul><li>exec</li></ul><p><code>exec</code> 与 <code>fork</code> 不同，不需要新开一个子 Shell 来执行被调用的脚本. 被调用的脚本与父脚本在同一个 Shell 内执行。<strong>但是使用 <code>exec</code> 调用一个新脚本以后, 父脚本中 <code>exec</code> 行之后的内容就不会再执行了。这是 exec 和 source 的区别。</strong></p><p>参考： <a href="https://blog.csdn.net/simple_the_best/article/details/76285429" target="_blank" rel="noopener">在 Shell 脚本中调用另一个 Shell 脚本的三种方式</a></p><h2 id="处理命令行参数"><a href="#处理命令行参数" class="headerlink" title="处理命令行参数"></a>处理命令行参数</h2><ul><li>手工处理方式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>因为手工处理高度依赖于命令行上所传参数的位置，所以一般都只用来处理较简单的参数。</p><ul><li>getopts</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">"a:bc"</span> arg <span class="comment"># 选项后面的冒号表示该选项需要参数</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$arg</span> <span class="keyword">in</span></span><br><span class="line">             a)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"a's arg: <span class="variable">$OPTARG</span>"</span> <span class="comment"># 参数存在$OPTARG中</span></span><br><span class="line">                ;;</span><br><span class="line">             b)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"b"</span></span><br><span class="line">                ;;</span><br><span class="line">             c)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"c"</span></span><br><span class="line">                ;;</span><br><span class="line">             ?)  <span class="comment"># 当有不认识的选项的时候arg为?</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"unkonw argument"</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">        ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><code>getopts</code> 是由bash内置的，它不支持长选项。</p><ul><li>getopt</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>getopt</code> 和 <code>getopts</code> 功能相似但又不完全相同，<code>getopt</code> 是独立的可执行文件</p><p>参考：</p><ul><li><a href="https://blog.linuxeye.cn/389.html" target="_blank" rel="noopener">getopt：命令行选项、参数处理</a></li><li><a href="http://www.cnblogs.com/FrankTan/archive/2010/03/01/1634516.html" target="_blank" rel="noopener">Shell 中命令行选项/参数处理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设置默认值&quot;&gt;&lt;a href=&quot;#设置默认值&quot; class=&quot;headerlink&quot; title=&quot;设置默认值&quot;&gt;&lt;/a&gt;设置默认值&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;变量为 null 时，则 var=b&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="Shell" scheme="https://huangwenren.github.io/categories/Shell/"/>
    
    
  </entry>
  
  <entry>
    <title>学习资源</title>
    <link href="https://huangwenren.github.io/2018/09/06/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    <id>https://huangwenren.github.io/2018/09/06/学习资源/</id>
    <published>2018-09-06T13:00:22.000Z</published>
    <updated>2018-09-06T13:03:29.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔面试相关"><a href="#笔面试相关" class="headerlink" title="笔面试相关"></a>笔面试相关</h2><ul><li><a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/index.html" target="_blank" rel="noopener">《编程之法：面试和算法心得》</a></li></ul><p>-<a href=""></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;笔面试相关&quot;&gt;&lt;a href=&quot;#笔面试相关&quot; class=&quot;headerlink&quot; title=&quot;笔面试相关&quot;&gt;&lt;/a&gt;笔面试相关&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://wizardforcel.gitbooks.io/the-art-of
      
    
    </summary>
    
      <category term="资源" scheme="https://huangwenren.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Dockerfile入门</title>
    <link href="https://huangwenren.github.io/2018/09/06/Dockerfile%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/09/06/Dockerfile入门/</id>
    <published>2018-09-06T12:38:23.000Z</published>
    <updated>2018-09-06T12:56:50.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前台运行"><a href="#前台运行" class="headerlink" title="前台运行"></a>前台运行</h2><ol><li>方法一：通过循环实现</li></ol><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM $&#123;BASE_IMAGE&#125;</span><br><span class="line"></span><br><span class="line">MAINTAINER huangwenren &lt;huangwenren1994@foxmail.com&gt;</span><br><span class="line"></span><br><span class="line">COPY ./bin/configtxgen /usr/local/bin/</span><br><span class="line"></span><br><span class="line">RUN chmod +x /usr/local/bin/configtxgen</span><br><span class="line"></span><br><span class="line">COPY ./configtx.yaml /etc/hyperledger/</span><br><span class="line"></span><br><span class="line">RUN apt-get install -y apg</span><br><span class="line"></span><br><span class="line">EXPOSE 7054</span><br><span class="line"></span><br><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;while true; do echo &apos;fabric-ca-client is running&apos;; sleep 10; done&quot; ]</span><br></pre></td></tr></table></figure><ol start="2"><li>方法二： 通过 supervisor 管理</li></ol><p>eg:</p><ol start="3"><li>方法三： 如果该程序支持前台运行，则可直接要求程序以前台形式运行</li></ol><p>eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-拷贝保存子目录结构"><a href="#Dockerfile-拷贝保存子目录结构" class="headerlink" title="Dockerfile 拷贝保存子目录结构"></a>Dockerfile 拷贝保存子目录结构</h2><p>错误方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY files/* /files/</span><br></pre></td></tr></table></figure><p>正确方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY files/ /files/</span><br></pre></td></tr></table></figure><p>两者区别在于有无 * 标</p><p>参考： <a href="https://codeday.me/bug/20170910/68286.html" target="_blank" rel="noopener">Dockerfile 拷贝保存子目录结构</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">Docker —— 从入门到实践</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前台运行&quot;&gt;&lt;a href=&quot;#前台运行&quot; class=&quot;headerlink&quot; title=&quot;前台运行&quot;&gt;&lt;/a&gt;前台运行&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;方法一：通过循环实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="Docker" scheme="https://huangwenren.github.io/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>first-network测试</title>
    <link href="https://huangwenren.github.io/2018/09/02/balance-transfer%E6%B5%8B%E8%AF%95/"/>
    <id>https://huangwenren.github.io/2018/09/02/balance-transfer测试/</id>
    <published>2018-09-02T09:41:45.424Z</published>
    <updated>2018-09-02T11:06:50.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载-fabric-sample-代码"><a href="#下载-fabric-sample-代码" class="headerlink" title="下载 fabric-sample 代码"></a>下载 fabric-sample 代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hyperledger/fabric-samples.git</span><br></pre></td></tr></table></figure><h2 id="进入-fabric-sample-目录"><a href="#进入-fabric-sample-目录" class="headerlink" title="进入 fabric-sample 目录"></a>进入 fabric-sample 目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fabric-samples</span><br></pre></td></tr></table></figure><h2 id="下载二进制文件，需指定当前-fabric-sample-的版本"><a href="#下载二进制文件，需指定当前-fabric-sample-的版本" class="headerlink" title="下载二进制文件，需指定当前 fabric-sample 的版本"></a>下载二进制文件，需指定当前 fabric-sample 的版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://goo.gl/6wtTN5 | bash -s <span class="variable">$&#123;VERSION&#125;</span></span><br></pre></td></tr></table></figure><p>最近发现了一个<strong>速度更快的方法</strong>。<br>这个脚本文件其实在 fabric 中就已经存在了，直接利用 fabric 中的脚本也可以得到与上面命令一样的效果，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric/scripts/bootstrap.sh ./</span><br><span class="line"></span><br><span class="line">chmod +x bootstrap.sh</span><br><span class="line"></span><br><span class="line">./bootstrap.sh</span><br></pre></td></tr></table></figure><h2 id="进入-first-network-目录"><a href="#进入-first-network-目录" class="headerlink" title="进入 first-network 目录"></a>进入 first-network 目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> first-network</span><br></pre></td></tr></table></figure><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h2><ol><li>终端 1</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./runApp.sh</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">2. 终端 2</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">sudo yum install -y jq</span><br><span class="line"></span><br><span class="line">./testApp.sh</span><br></pre></td></tr></table></figure><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h2><ol><li>终端 1</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f artifacts/docker-compose.yaml up</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">2. 终端 2</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/zhayujie5200/article/details/79684032" target="_blank" rel="noopener">balance transfer（一）启动示例</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;下载-fabric-sample-代码&quot;&gt;&lt;a href=&quot;#下载-fabric-sample-代码&quot; class=&quot;headerlink&quot; title=&quot;下载 fabric-sample 代码&quot;&gt;&lt;/a&gt;下载 fabric-sample 代码&lt;/h2&gt;&lt;figu
      
    
    </summary>
    
      <category term="Fabric" scheme="https://huangwenren.github.io/categories/Fabric/"/>
    
    
  </entry>
  
  <entry>
    <title>CouchDB入门</title>
    <link href="https://huangwenren.github.io/2018/08/29/CouchDB%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/08/29/CouchDB入门/</id>
    <published>2018-08-29T14:29:10.000Z</published>
    <updated>2018-08-29T14:35:40.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CouchDB是一个开源的面向文档的数据库管理系统。</p><h2 id="CouchDB-与-MongoDB-对比"><a href="#CouchDB-与-MongoDB-对比" class="headerlink" title="CouchDB 与 MongoDB 对比"></a>CouchDB 与 MongoDB 对比</h2><p>满足海量存储需求和访问的面向文档的数据库：MongoDB，CouchDB</p><p>面向文档的非关系数据库主要解决的问题不是高性能的并发读写，而是保证海量数据存储的同时，具有良好的查询性能。MongoDB是用C++开发的，而 CouchDB则是Erlang开发的：</p><ol><li>MongoDB</li></ol><p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似 json 的 bjson 格式，因此可以存储比较复杂的数据类型。Mongo 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><p>Mongo 主要解决的是海量数据的访问效率问题，根据官方的文档，当数据量达到50GB以上的时候，Mong o的数据库访问速度是 MySQL 的 10 倍以 上。Mongo 的并发读写效率不是特别出色，根据官方提供的性能测试表明，大约每秒可以处理 0.5 万－1.5 万次读写请求。</p><p>因为 Mongo 主要是支持海量数据存储的，所以 Mongo 还自带了一个出色的分布式文件系统 GridFS，可以支持海量的数据存储，但我也看到有些评论认为 GridFS 性能不佳，这一点还是有待亲自做点测试来验证了。</p><p>最后由于 Mongo 可以支持复杂的数据结构，而且带有强大的数据查询功能，因此非常受到欢迎，很多项目都考虑用 MongoDB 来替代 MySQL 来实现不是 特别复杂的 Web 应用，比方说 why we migrated from MySQL to MongoDB 就是一个真实的从MySQL迁移到 MongoDB 的案例，由于数据量实在太大，所以迁移到了 Mongo 上面，数据查询的速度得到了非常显著的提升。</p><p>MongoD B也有一个 ruby 的项目 MongoMapper，是模仿 Merb 的 DataMapper 编写的 MongoDB 的接口，使用起来非常简单，几乎和 DataMapper 一模一样，功能非常强大易用。</p><ol start="2"><li>CouchDB</li></ol><p>CouchDB现在是一个非常有名气的项目，似乎不用多介绍了。但是我却对 CouchDB 没有什么兴趣，主要是因为 CouchDB 仅仅提供了基于 HTTP REST 的接口，因此 CouchDB 单纯从并发读写性能来说，是非常糟糕的，这让我立刻抛弃了对 CouchDB 的兴趣。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;CouchDB是一个开源的面向文档的数据库管理系统。&lt;/p&gt;
&lt;h2 id=&quot;CouchDB-与-MongoDB-对比&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="CouchDB" scheme="https://huangwenren.github.io/categories/CouchDB/"/>
    
    
  </entry>
  
  <entry>
    <title>BitMap算法</title>
    <link href="https://huangwenren.github.io/2018/08/29/BitMap%E7%AE%97%E6%B3%95/"/>
    <id>https://huangwenren.github.io/2018/08/29/BitMap算法/</id>
    <published>2018-08-29T06:14:39.000Z</published>
    <updated>2018-08-29T06:15:03.122Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Algorithm" scheme="https://huangwenren.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下密码生成软件APG</title>
    <link href="https://huangwenren.github.io/2018/08/29/Linux%E4%B8%8B%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E8%BD%AF%E4%BB%B6APG/"/>
    <id>https://huangwenren.github.io/2018/08/29/Linux下密码生成软件APG/</id>
    <published>2018-08-29T03:48:36.000Z</published>
    <updated>2018-08-29T03:59:14.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>APG是一款轻巧的密码生成软件，全称 Automated Password Generator（简称“APG”）。APG 在 Linux 使用，当然也有 Windows 版的，命令简单，可以批量生成，当需要若干随机密码时，可用该软件。</p><h2 id="APG-的使用"><a href="#APG-的使用" class="headerlink" title="APG 的使用"></a>APG 的使用</h2><p>直接输入 <code>apg</code> 默认生成 6 个随机密码</p><h2 id="APG-的可选参数"><a href="#APG-的可选参数" class="headerlink" title="APG 的可选参数"></a>APG 的可选参数</h2><p>m 指生成密码的位数，默认是8位</p><p>M mode  使用模式生成密码</p><p>-M mode S, s, N, n, C, c, L, l.</p><p>S  每个密码必须都有特殊字符</p><p>s  包含特殊字条但不一定每个都有</p><p>N  每个密码必需含有数字</p><p>n  包含数字</p><p>C  每个密码必需有大写字母</p><p>c  包含大写字母</p><p>L  每个密码必需有小写字母</p><p>l  包含有小写</p><h2 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h2><p>随机生成 7 个 16 位的包含大小写、特殊字符、数字的密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apg -M SNCL -m 16 -n 7</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/xhch2009/article/details/18222263" target="_blank" rel="noopener">Linux下密码生成软件APG</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;APG是一款轻巧的密码生成软件，全称 Automated Password Generator（简称“APG”）。APG 在 Linux 使
      
    
    </summary>
    
      <category term="Linux" scheme="https://huangwenren.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>利用Vagrant搭建Fabric开发环境</title>
    <link href="https://huangwenren.github.io/2018/08/28/%E5%88%A9%E7%94%A8Vagrant%E6%90%AD%E5%BB%BAFabric%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://huangwenren.github.io/2018/08/28/利用Vagrant搭建Fabric开发环境/</id>
    <published>2018-08-28T14:52:34.000Z</published>
    <updated>2018-08-28T14:52:59.747Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Fabric" scheme="https://huangwenren.github.io/categories/Fabric/"/>
    
    
  </entry>
  
  <entry>
    <title>ES入门</title>
    <link href="https://huangwenren.github.io/2018/08/28/ES%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/08/28/ES入门/</id>
    <published>2018-08-28T13:45:03.000Z</published>
    <updated>2018-08-28T13:46:38.953Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://huangwenren.github.io/categories/Elasticsearch/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx反向代理</title>
    <link href="https://huangwenren.github.io/2018/08/28/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://huangwenren.github.io/2018/08/28/Nginx反向代理/</id>
    <published>2018-08-28T13:37:29.000Z</published>
    <updated>2018-08-28T13:42:42.100Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map <span class="variable">$http_upgrade</span> <span class="variable">$connection_upgrade</span> &#123;</span><br><span class="line">    default upgrade;</span><br><span class="line">    <span class="string">''</span>  close;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改Nginx的配置文件（具体配置文件的路径，参照Nginx的安装路径。在10.19.49.64这台物理机上，nginx安装在/usr/local/nginx）</span></span><br><span class="line">vim /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在nginx.conf中添加如下内容：</span></span><br><span class="line"> </span><br><span class="line">        location /<span class="variable">$&#123;cluster&#125;</span>/<span class="variable">$&#123;keytab&#125;</span>/ &#123;</span><br><span class="line">            proxy_pass  http://<span class="variable">$&#123;ip&#125;</span>:<span class="variable">$&#123;port&#125;</span>/;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">            proxy_set_header Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Nginx" scheme="https://huangwenren.github.io/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux中增加swap空间</title>
    <link href="https://huangwenren.github.io/2018/08/28/Linux%E4%B8%AD%E5%A2%9E%E5%8A%A0swap%E7%A9%BA%E9%97%B4/"/>
    <id>https://huangwenren.github.io/2018/08/28/Linux中增加swap空间/</id>
    <published>2018-08-28T02:53:58.000Z</published>
    <updated>2018-08-28T14:07:04.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于 memory 没什么可说的就是机器的物理内存，读写速度低于 cpu 一个量级，但是高于磁盘不止一个量级。所以，程序和数据如果在内存的话，会有非常快的读写速度。但是，内存的造价是要高于磁盘的，虽然相对来说价格一直在降低。除此之外，内存的断电丢失数据也是一个原因说不能把所有数据和程序都保存在内存中。既然不能全部使用内存，那数据还有程序肯定不可能一直霸占在内存中。当内存没有可用的，就必须要把内存中不经常运行的程序给踢出去。但是踢到哪里去，这时候 swap 就出现了。swap 全称为 swap place，，即交换区，当内存不够的时候，被踢出的进程被暂时存储到交换区。当需要这条被踢出的进程的时候，就从交换区重新加载到内存，否则它不会主动交换到真是内存中。</p><p>在安装 Linux 的时候，不知道 swap 空间分配多少比较好，所以会随便分配一个。在真正使用的时候，比如安装 Oracle10g 会要求很大的 swap 空间，发现 swap 空间不够，那应该怎么增加 swap 空间大小呢。</p><h2 id="查看原-swap-分区大小"><a href="#查看原-swap-分区大小" class="headerlink" title="查看原 swap 分区大小"></a>查看原 swap 分区大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free m</span><br></pre></td></tr></table></figure><h2 id="建立一个分区"><a href="#建立一个分区" class="headerlink" title="建立一个分区"></a>建立一个分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/home/swap bs=1024 count=512000</span><br></pre></td></tr></table></figure><p>这样就会创建 /home/swap 这么一个分区文件。文件的大小是 512000 个 block，一般情况下 1 个 block 为 1K，所以这里空间是 512M。</p><h2 id="将分区变成-swap-分区"><a href="#将分区变成-swap-分区" class="headerlink" title="将分区变成 swap 分区"></a>将分区变成 swap 分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/mkswap /home/swap</span><br></pre></td></tr></table></figure><h2 id="使用这个-swap-分区-使其成为有效状态"><a href="#使用这个-swap-分区-使其成为有效状态" class="headerlink" title="使用这个 swap 分区,使其成为有效状态"></a>使用这个 swap 分区,使其成为有效状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/swapon /home/swap</span><br></pre></td></tr></table></figure><h2 id="查看当前内存和-swap-分区大小"><a href="#查看当前内存和-swap-分区大小" class="headerlink" title="查看当前内存和 swap 分区大小"></a>查看当前内存和 swap 分区大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free m</span><br></pre></td></tr></table></figure><p>可以发现增加了 512M 的空间了。不过当计算机重启了以后，发现 swap 还是原来那么大，新的 swap 没有自动启动，还要手动启动。那我们需要修改 /etc/fstab 文件，增加如下一行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/swap swap swap defaults 0 0</span><br></pre></td></tr></table></figure><p>这样一来，机器就算重新启动，swap 空间也会自动增大。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/zwan0518/article/details/12059213" target="_blank" rel="noopener">Linux中Swap与Memory内存简单介绍</a><br><a href="https://blog.csdn.net/zhang123456456/article/details/78055059" target="_blank" rel="noopener">Linux之增加swap空间</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;对于 memory 没什么可说的就是机器的物理内存，读写速度低于 cpu 一个量级，但是高于磁盘不止一个量级。所以，程序和数据如果在内存的话
      
    
    </summary>
    
      <category term="Linux" scheme="https://huangwenren.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Git入门</title>
    <link href="https://huangwenren.github.io/2018/08/27/Git%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/08/27/Git入门/</id>
    <published>2018-08-27T15:04:22.000Z</published>
    <updated>2018-08-27T15:04:37.987Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Git" scheme="https://huangwenren.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Top K问题</title>
    <link href="https://huangwenren.github.io/2018/08/27/TopK%E9%97%AE%E9%A2%98/"/>
    <id>https://huangwenren.github.io/2018/08/27/TopK问题/</id>
    <published>2018-08-27T03:44:40.549Z</published>
    <updated>2018-09-06T13:05:27.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><h3 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h3><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://songlee24.github.io/2015/03/21/hua-wei-OJ2051/" target="_blank" rel="noopener">华为OJ2051-最小的K个数（Top K问题）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解法&quot;&gt;&lt;a href=&quot;#解法&quot; class=&quot;headerlink&quot; title=&quot;解法&quot;&gt;&lt;/a&gt;解法&lt;/h2&gt;&lt;h3 id=&quot;解法一&quot;&gt;&lt;a href=&quot;#解法一&quot; class=&quot;headerlink&quot; title=&quot;解法一&quot;&gt;&lt;/a&gt;解法一&lt;/h3&gt;&lt;h
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://huangwenren.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo文章摘要</title>
    <link href="https://huangwenren.github.io/2018/08/26/Hexo%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81/"/>
    <id>https://huangwenren.github.io/2018/08/26/Hexo文章摘要/</id>
    <published>2018-08-26T08:28:54.357Z</published>
    <updated>2018-08-27T14:58:30.107Z</updated>
    
    <content type="html"><![CDATA[<p>摘要</p><a id="more"></a><p>正文内容</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://huangwenren.github.io/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>first-network测试</title>
    <link href="https://huangwenren.github.io/2018/08/23/first-network%E6%B5%8B%E8%AF%95/"/>
    <id>https://huangwenren.github.io/2018/08/23/first-network测试/</id>
    <published>2018-08-23T09:34:02.052Z</published>
    <updated>2018-08-28T14:10:53.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载-fabric-sample-代码"><a href="#下载-fabric-sample-代码" class="headerlink" title="下载 fabric-sample 代码"></a>下载 fabric-sample 代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hyperledger/fabric-samples.git</span><br></pre></td></tr></table></figure><h2 id="进入-fabric-sample-目录"><a href="#进入-fabric-sample-目录" class="headerlink" title="进入 fabric-sample 目录"></a>进入 fabric-sample 目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fabric-samples</span><br></pre></td></tr></table></figure><h2 id="下载二进制文件，需指定当前-fabric-sample-的版本"><a href="#下载二进制文件，需指定当前-fabric-sample-的版本" class="headerlink" title="下载二进制文件，需指定当前 fabric-sample 的版本"></a>下载二进制文件，需指定当前 fabric-sample 的版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://goo.gl/6wtTN5 | bash -s <span class="variable">$&#123;VERSION&#125;</span></span><br></pre></td></tr></table></figure><p>最近发现了一个<strong>速度更快的方法</strong>。<br>这个脚本文件其实在 fabric 中就已经存在了，直接利用 fabric 中的脚本也可以得到与上面命令一样的效果，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric/scripts/bootstrap.sh ./</span><br><span class="line"></span><br><span class="line">chmod +x bootstrap.sh</span><br><span class="line"></span><br><span class="line">./bootstrap.sh</span><br></pre></td></tr></table></figure><h2 id="进入-first-network-目录"><a href="#进入-first-network-目录" class="headerlink" title="进入 first-network 目录"></a>进入 first-network 目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> first-network</span><br></pre></td></tr></table></figure><h2 id="生成网络构件"><a href="#生成网络构件" class="headerlink" title="生成网络构件"></a>生成网络构件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./byfn.sh generate</span><br></pre></td></tr></table></figure><h2 id="启动网络"><a href="#启动网络" class="headerlink" title="启动网络"></a>启动网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./byfn.sh up</span><br></pre></td></tr></table></figure><h2 id="关闭网络"><a href="#关闭网络" class="headerlink" title="关闭网络"></a>关闭网络</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./byfn.sh down</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://hyperledger-fabric.readthedocs.io/en/latest/build_network.html" target="_blank" rel="noopener">官方文档</a><br><a href="https://hyperledger-fabric.readthedocs.io/en/latest/install.html" target="_blank" rel="noopener">安装二进制文件</a><br><a href="https://blog.csdn.net/mellymengyan/article/details/77671185" target="_blank" rel="noopener">cryptogen tool not found. exiting错误解决办法</a></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li>没有 down 网络，导致 up 网络失败。解决方法：先 down 网络，然后再 up <a href="https://stackoverflow.com/questions/48151804/error-got-unexpected-status-forbidden-failed-to-reach-implicit-threshold-of?rq=1" target="_blank" rel="noopener">详情可参照这个 stack overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;下载-fabric-sample-代码&quot;&gt;&lt;a href=&quot;#下载-fabric-sample-代码&quot; class=&quot;headerlink&quot; title=&quot;下载 fabric-sample 代码&quot;&gt;&lt;/a&gt;下载 fabric-sample 代码&lt;/h2&gt;&lt;figu
      
    
    </summary>
    
      <category term="Fabric" scheme="https://huangwenren.github.io/categories/Fabric/"/>
    
    
  </entry>
  
  <entry>
    <title>Vagrant 入门</title>
    <link href="https://huangwenren.github.io/2018/08/22/vagrant%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/08/22/vagrant入门/</id>
    <published>2018-08-22T09:05:40.000Z</published>
    <updated>2018-08-27T14:57:10.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p><strong>Vagrant 和 VirtualBox 的版本需要对应好，否则 Vagrant 可能会无法操作VirtualBox</strong></p><p>目前在以下版本测试成功（<a href="https://www.vagrantup.com/docs/virtualbox/" target="_blank" rel="noopener">查看 Vagrant 支持的 VirtualBox 版本</a>）：</p><ul><li>Vagrant 1.9.3</li><li>VirtualBox 4.3.40</li></ul><h2 id="Vagrant-Box-下载"><a href="#Vagrant-Box-下载" class="headerlink" title="Vagrant Box 下载"></a>Vagrant Box 下载</h2><p><a href="http://www.vagrantbox.es/" target="_blank" rel="noopener">Vagrant Box 下载地址</a></p><h2 id="Vagrant-常用命令"><a href="#Vagrant-常用命令" class="headerlink" title="Vagrant 常用命令"></a>Vagrant 常用命令</h2><ul><li>vagrant box add    添加box的操作</li><li>vagrant init    初始化box的操作，会生成 vagrant 的配置文件 Vagrantfile</li><li>vagrant up    启动本地环境</li><li>vagrant ssh    通过 ssh 登录本地环境所在虚拟机</li><li>vagrant halt    关闭本地环境</li><li>vagrant suspend    暂停本地环境</li><li>vagrant resume    恢复本地环境</li><li>vagrant reload    修改了 Vagrantfile 后，使之生效（相当于先 halt，再 up）</li><li>vagrant destroy    彻底移除本地环境</li><li>vagrant box list    显示当前已经添加的box列表</li><li>vagrant box remove    删除相应的box</li><li>vagrant package    打包命令，可以把当前的运行的虚拟机环境进行打包</li><li>vagrant plugin    用于安装卸载插件</li><li>vagrant status    获取当前虚拟机的状态</li><li>vagrant global-status    显示当前用户 vagrant 的所有环境状态</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.imooc.com/search/?words=vagrant" target="_blank" rel="noopener">慕课网教学视频</a></li><li><a href="https://github.com/apanly/mooc/tree/master/vagrant" target="_blank" rel="noopener">慕课网教学视频对应 GitHub</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;版本选择&quot;&gt;&lt;a href=&quot;#版本选择&quot; class=&quot;headerlink&quot; title=&quot;版本选择&quot;&gt;&lt;/a&gt;版本选择&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Vagrant 和 VirtualBox 的版本需要对应好，否则 Vagrant 可能会无法操作Virtua
      
    
    </summary>
    
      <category term="Vagrant" scheme="https://huangwenren.github.io/categories/Vagrant/"/>
    
    
  </entry>
  
  <entry>
    <title>docker入门</title>
    <link href="https://huangwenren.github.io/2018/08/22/docker%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/08/22/docker入门/</id>
    <published>2018-08-22T08:54:03.000Z</published>
    <updated>2018-08-28T14:54:50.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#确保 yum 包更新到最新</span></span><br><span class="line">sudo yum update</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行 Docker 安装脚本,执行这个脚本会添加 docker.repo 源并安装 Docker。</span></span><br><span class="line">curl -fsSL https://get.docker.com/ | sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动 Docker 进程</span></span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证 docker 是否安装成功并在容器中执行一个测试的镜像</span></span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a>删除所有容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure><h2 id="删除所有镜像"><a href="#删除所有镜像" class="headerlink" title="删除所有镜像"></a>删除所有镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $(docker images -aq)</span><br></pre></td></tr></table></figure><h2 id="容器中查看-Linux-版本"><a href="#容器中查看-Linux-版本" class="headerlink" title="容器中查看 Linux 版本"></a>容器中查看 Linux 版本</h2><p>正确的姿势：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure></p><p>错误的姿势：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version </span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">uname -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上诉两个方法查到的是宿主机的系统</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-Docker&quot;&gt;&lt;a href=&quot;#安装-Docker&quot; class=&quot;headerlink&quot; title=&quot;安装 Docker&quot;&gt;&lt;/a&gt;安装 Docker&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="Docker" scheme="https://huangwenren.github.io/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo中使用本地图片</title>
    <link href="https://huangwenren.github.io/2018/08/21/Hexo%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"/>
    <id>https://huangwenren.github.io/2018/08/21/Hexo中使用本地图片/</id>
    <published>2018-08-21T08:16:20.000Z</published>
    <updated>2018-08-28T13:34:15.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h2><p>在全局的 _config.yml 中设置 post_asset_folder 属性为 true</p><h2 id="安装-node-模块"><a href="#安装-node-模块" class="headerlink" title="安装 node 模块"></a>安装 node 模块</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n post <span class="string">"Using Local Image in Hexo"</span></span><br></pre></td></tr></table></figure><p>_post 目录下会生成与 .md 文件同名的目录，将图片 nasa.jpg 拷贝到目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Using-Local-Image-in-Hexo</span><br><span class="line">│   └── nasa.jpg</span><br><span class="line">└── Using-Local-Image-in-Hexo.md</span><br></pre></td></tr></table></figure><h2 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![nasa](Using-Local-Image-in-Hexo/nasa.jpg)</span><br></pre></td></tr></table></figure><h2 id="具体效果"><a href="#具体效果" class="headerlink" title="具体效果"></a>具体效果</h2><p><img src="/2018/08/21/Hexo中使用本地图片/nasa.jpg" alt="nasa"> </p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://wonder4.me/2017/02/20/Using-Local-Image-in-Hexo/" target="_blank" rel="noopener">在 Hexo 中使用本地图片</a></p><p><a href="https://theme-next.iissnan.com/getting-started.html#install-next-theme" target="_blank" rel="noopener">Next主题文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;修改站点配置文件&quot;&gt;&lt;a href=&quot;#修改站点配置文件&quot; class=&quot;headerlink&quot; title=&quot;修改站点配置文件&quot;&gt;&lt;/a&gt;修改站点配置文件&lt;/h2&gt;&lt;p&gt;在全局的 _config.yml 中设置 post_asset_folder 属性为 tru
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python入门</title>
    <link href="https://huangwenren.github.io/2018/08/21/Python%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwenren.github.io/2018/08/21/Python入门/</id>
    <published>2018-08-21T07:50:23.000Z</published>
    <updated>2018-08-21T07:51:51.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;todo&quot;&gt;&lt;a href=&quot;#todo&quot; class=&quot;headerlink&quot; title=&quot;todo&quot;&gt;&lt;/a&gt;todo&lt;/h2&gt;
      
    
    </summary>
    
      <category term="Python" scheme="https://huangwenren.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="https://huangwenren.github.io/2018/08/21/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://huangwenren.github.io/2018/08/21/Linux常用命令/</id>
    <published>2018-08-21T07:49:22.000Z</published>
    <updated>2018-09-03T03:22:14.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历文件夹查找文本内容</span></span><br><span class="line">grep -r <span class="string">"查找文本内容"</span> *</span><br></pre></td></tr></table></figure><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><ul><li>全局替换  <h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2></li></ul><h2 id="ssh-copy-id"><a href="#ssh-copy-id" class="headerlink" title="ssh-copy-id"></a>ssh-copy-id</h2><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p><a href="https://www.cnblogs.com/jyaray/archive/2011/04/30/2033362.html" target="_blank" rel="noopener">tar压缩解压缩命令详解</a></p><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>%s/{old}/{new}/g</p><h2 id="查看文件夹大小"><a href="#查看文件夹大小" class="headerlink" title="查看文件夹大小"></a>查看文件夹大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h --max-depth=1 ./</span><br></pre></td></tr></table></figure><h2 id="查看磁盘大小"><a href="#查看磁盘大小" class="headerlink" title="查看磁盘大小"></a>查看磁盘大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查看内存大小"><a href="#查看内存大小" class="headerlink" title="查看内存大小"></a>查看内存大小</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="关闭进程"><a href="#关闭进程" class="headerlink" title="关闭进程"></a>关闭进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TRUNCATE 只能用来清除整个表的数据，而 DELETE 可以根据条件删除某些记录。</p><p>TRUNCATE 删除是不可恢复的！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;grep&quot;&gt;&lt;a href=&quot;#grep&quot; class=&quot;headerlink&quot; title=&quot;grep&quot;&gt;&lt;/a&gt;grep&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="Linux" scheme="https://huangwenren.github.io/categories/Linux/"/>
    
    
  </entry>
  
</feed>
